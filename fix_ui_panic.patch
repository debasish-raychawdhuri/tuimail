--- a/src/ui.rs
+++ b/src/ui.rs
@@ -1003,6 +1003,35 @@ fn centered_rect(percent_x: u16, percent_y: u16, r: Rect) -> Rect {
         .split(popup_layout[1])[1]
 }
 
+/// Helper function to safely convert byte position to character position
+fn byte_to_char_pos(text: &str, byte_pos: usize) -> usize {
+    text.char_indices()
+        .position(|(i, _)| i >= byte_pos)
+        .unwrap_or(text.chars().count())
+}
+
+/// Helper function to safely convert character position to byte position
+fn char_to_byte_pos(text: &str, char_pos: usize) -> usize {
+    text.char_indices()
+        .nth(char_pos)
+        .map(|(i, _)| i)
+        .unwrap_or(text.len())
+}
+
+/// Helper function to safely slice text by character positions
+fn safe_char_slice(text: &str, start_char: usize, end_char: usize) -> String {
+    text.chars()
+        .skip(start_char)
+        .take(end_char.saturating_sub(start_char))
+        .collect()
+}
+
+/// Helper function to safely slice text from character position to end
+fn safe_char_slice_from(text: &str, start_char: usize) -> String {
+    text.chars()
+        .skip(start_char)
+        .collect()
+}
+
 /// Helper function to create text with highlighted misspelled words
 fn create_highlighted_text(text: &str, spell_errors: &[crate::spellcheck::SpellError], show_cursor: bool, cursor_pos: usize) -> ratatui::text::Text<'static> {
     let mut spans = Vec::new();
@@ -1011,25 +1040,42 @@ fn create_highlighted_text(text: &str, spell_errors: &[crate::spellcheck::SpellE
     // Sort errors by position to process them in order
     let mut sorted_errors = spell_errors.to_vec();
     sorted_errors.sort_by_key(|e| e.position);
+    
+    // Convert text to character positions for safe processing
+    let text_chars: Vec<char> = text.chars().collect();
+    let text_len_chars = text_chars.len();
     
     // Process each error and create styled spans
     for error in sorted_errors {
-        // Add normal text before the error
-        if error.position > last_pos {
-            let normal_text = text[last_pos..error.position].to_string();
+        // Convert byte positions to character positions
+        let error_start_char = byte_to_char_pos(text, error.position);
+        let error_end_char = error_start_char + error.word.chars().count();
+        
+        // Bounds checking
+        if error_start_char >= text_len_chars {
+            continue;
+        }
+        
+        let error_end_char = error_end_char.min(text_len_chars);
+        
+        // Add normal text before the error
+        if error_start_char > last_pos {
+            let normal_text = safe_char_slice(text, last_pos, error_start_char);
             spans.push(Span::raw(normal_text));
         }
         
         // Add the misspelled word with red background
-        let error_end = error.position + error.word.len();
-        let error_text = text[error.position..error_end].to_string();
+        let error_text = safe_char_slice(text, error_start_char, error_end_char);
         spans.push(Span::styled(
             error_text, 
             Style::default().bg(Color::Red).fg(Color::White)
         ));
         
-        last_pos = error_end;
+        last_pos = error_end_char;
     }
     
     // Add remaining text after the last error
-    if last_pos < text.len() {
-        spans.push(Span::raw(text[last_pos..].to_string()));
+    if last_pos < text_len_chars {
+        let remaining_text = safe_char_slice_from(text, last_pos);
+        spans.push(Span::raw(remaining_text));
     }
     
     // If showing cursor, insert it at the cursor position
